{% extends "base.html" %}

{% block webglscript %}

//--------------- WEBGL ---------------

if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

THREE.Cache.enabled = true;
var container, stats, controls, hex, color;
var camera, cameraTarget, scene, renderer;
var group, textMesh, textGeo, material;
var scale = 3;

var sphereMaterials = {};
var lineMaterials = {};
var textMeshes = [];

var firstLetter = true;

var text,
height = 1,
size = 20,
hover = 20,
curveSegments = 4,
bevelThickness = 2,
bevelSize = 1.5,
bevelSegments = 3,
bevelEnabled = true,
font = undefined;

var windowHalfX = window.innerWidth / 2;
var windowHalfY = window.innerHeight / 2;

init();
animate();
startAttenuation();

function init() {
  container = document.createElement( 'div' );
  document.body.appendChild( container );

  // CAMERA

  camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
  camera.position.set( 6000, 2850, 3950 );

  cameraTarget = new THREE.Vector3( 2500, 1500, 2050 );
  camera.lookAt( cameraTarget );

  // SCENE

  scene = new THREE.Scene();
  scene.fog = new THREE.Fog( 0x222222, 150, 12000 );

  // LIGHTS
  var ambient = new THREE.AmbientLight(0xffffff);
  scene.add(ambient);

  material = new THREE.MultiMaterial( [
    new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.FlatShading } ), // front
    new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.SmoothShading } ) // side
  ] );

  group = new THREE.Group();
  group.position.y = 100;

  scene.add( group );

  loadFont();

  // RENDERER

  renderer = new THREE.WebGLRenderer( { antialias: true } );
  renderer.setClearColor( scene.fog.color );
  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize( window.innerWidth, window.innerHeight );
  container.appendChild( renderer.domElement );

  // ORBITCONTROLS

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.maxDistance = 10000;

  // STATS

  stats = new Stats();
  stats.domElement.style.position = 'absolute';
  stats.domElement.style.top = '0px';
  //container.appendChild( stats.domElement );

  window.addEventListener( 'resize', onWindowResize, false );
}

function onWindowResize() {
  windowHalfX = window.innerWidth / 2;
  windowHalfY = window.innerHeight / 2;

  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize( window.innerWidth, window.innerHeight );
}

function loadFont() {
  var loader = new THREE.FontLoader();
  loader.load( '/static/helvetiker_regular.typeface.js', function ( response ) {
  font = response;
  createText();
} );

}

function createText() {
  <!-- MeshCreate -->
  {% for cell in cells %}
    //sphere material
    smaterial = new THREE.MeshLambertMaterial({ color: 0x330000 });

    //sphere geometry
    radius = (Math.sqrt({{ cell["voxel"] }} / Math.PI));
    sphereGeo = new THREE.SphereGeometry(radius);

    //text geometry
    textGeo = new THREE.TextGeometry( "{{ cell['name'] }}", {
      font: font,
      size: size,
      height: height,
      curveSegments: curveSegments,
      bevelThickness: bevelThickness,
      bevelSize: bevelSize,
      bevelEnabled: bevelEnabled,
      material: 0,
      extrudeMaterial: 1
    });

    textGeo.computeBoundingBox();
    textGeo.computeVertexNormals();

    var centerOffset = -0.5 * ( textGeo.boundingBox.max.x - textGeo.boundingBox.min.x );

    sphereMesh = new THREE.Mesh( sphereGeo, smaterial );
    sphereMesh.position.x = centerOffset + ({{ cell['x'] }}/scale);
    sphereMesh.position.y = hover + ({{ cell['y'] }}/scale);
    sphereMesh.position.z = 0 + ({{ cell['z'] }}/scale);

    textMesh = new THREE.Mesh( textGeo, material );

    textMesh.position.x = centerOffset - radius/2 + ({{ cell['x'] }}/scale);
    textMesh.position.y = hover + radius + ({{ cell['y'] }}/scale);
    textMesh.position.z = 0 + ({{ cell['z'] }}/scale);

    textMesh.rotation.x = 0;
    textMesh.rotation.y = Math.PI * 2;

    sphereMaterials[{{ cell['id'] }}] = smaterial;
    textMeshes.push(textMesh);

    group.add( sphereMesh );
    group.add( textMesh );

  {% endfor %}

  {% for link in links %}
    //line material
    lmaterial = new THREE.LineBasicMaterial({ color: 0x003300 });

    //line geometry
    lineGeo = new THREE.Geometry();
    
    lineGeo.vertices.push(new THREE.Vector3({{link["root"]["x"]}}/scale, {{link["root"]["y"]}}/scale, {{link["root"]["z"]}}/scale ));
    lineGeo.vertices.push(new THREE.Vector3({{link["dest"]["x"]}}/scale, {{link["dest"]["y"]}}/scale, {{link["dest"]["z"]}}/scale ));

    line = new THREE.Line(lineGeo, lmaterial);

    if (!({{ link['root']['id'] }} in lineMaterials)){
      lineMaterials[{{ link['root']['id'] }}] = [];
    }

    lineMaterials[{{ link['root']['id'] }}].push(lmaterial);
    
    group.add( line );

  {% endfor %}
}

function animate() {
  requestAnimationFrame( animate );
  render();
  stats.update();
  controls.update();

}

function render() {
  for(var i = 0; i < textMeshes.length; ++i){
    textMeshes[i].rotation.setFromRotationMatrix( camera.matrix );
  }
  renderer.clear();
  renderer.render( scene, camera );
}


//--------------- ATTENUATION ---------------
function attenuate(){
  attenuation_rate = -0.04;
  for (var key in sphereMaterials){
    if (sphereMaterials[key].color.getHSL()["l"] > 0.12) {
      sphereMaterials[key].color.offsetHSL(0, 0, attenuation_rate);
    }
  }
  for (var key in lineMaterials){
    for (var i=0; i<lineMaterials[key].length; i++) {
      if (lineMaterials[key][i].color.getHSL()["l"] > 0.12) {
        lineMaterials[key][i].color.offsetHSL(0, 0, attenuation_rate);
      }
    }
  }
}

function startAttenuation(){
  interval = 200;
  setInterval("attenuate()", interval);
}

//--------------- WEBSOCKET ---------------

var socket = io.connect('http://' + document.domain + ':' + location.port)
socket.on('activation', function(data){
  for(var i=0; i<data.length; i++){
    index = data[i];
    if (sphereMaterials[index].color.getHSL()["l"] < 0.7) {
      sphereMaterials[index].color.offsetHSL(0, 0, 0.2);
    }
    if (index in lineMaterials){
      for(var j=0; j<lineMaterials[index].length; j++){
        if (lineMaterials[index][j].color.getHSL()["l"] < 0.7) {
          lineMaterials[index][j].color.offsetHSL(0, 0, 0.2);
        }
      }
    }
  }
});

{% endblock %}
